\chapter{Introduction}

The Graph Alignment, Identification and Analysis (GAIA) library and tool is an open source software
designed and developed for performing machine learning and analysis over graphs.
The software is being developed using the Java programming language
by the LINQs Group at the University of Maryland, College Park.
In this user guide, we first discuss the motivations and philosophy used
in developing GAIA in \secref{motivation} and \secref{philosophy}.
We then present GAIA as a tool in \chapref{basicuser} to demonstrate
how GAIA can be used most common experiments without writing
any code and only having to specify a configurations file for the
experimental parameters, model parameters, feature construction, and
statistics and other output of the experiment.
In \chapref{advanced}, we go beyond using GAIA simply as a tool
and discuss how to use GAIA as a library.  This allows users
to develop new implementations of different parts of GAIA (i.e., different models, statistics,
input formats, samplers, experiments, etc.) for custom experiments
or to try out different models.  Next, in \chapref{visualization}, we discuss
the network visualization tool implemented within GAIA.

\section{Motivation}
\label{motivation}
GAIA was developed to address a need in the machine learning and network
analysis community to have a framework to share, evaluate, and apply
different algorithms and models over graphs.  Prior to GAIA, testing or
applying network algorithms required re-implementing the code.
Not only does this make it difficult to do any meaningful comparisons,
hindering reproducibility of experiments,
this also results in wasted effort in the form of redundant code.
Moreover, this made it difficult to analyze the interplay
between different machine learning tasks over network needed
to look at the problem of Graph Identification.

With these problems in mind, GAIA was developed as a general
framework for implementing algorithms and methods for use
over general graph.  Special care was made to make GAIA
general enough to handle all different types and sizes of graphs,
as well as algorithms for the network based
problems defined in Diehl et al.\cite{getoor:kdd-exp05}, namely:
\begin{itemize}
\item data representation-Examining ways to represent different types of linked data.
\item object ranking-Using attributes and link structure to order a set of objects within a graph
\item group detection-Cluster objects in a graph into groups that share a common characteristic
\item collective classification-To predict labels of objects in a graph, making use
of correlations associated with how those objects are connected in the graph
\item link prediction-Predicted the existence of links in a graph
\item entity resolution-Resolving objects in a graph to the underlying entity it refers to
\item subgraph discovery-Find interesting or commonly occurring subgraphs in one or more graphs
\item graph classification-Predict the labels of whole graphs
\item generative models-Analyze ways in which graphs with common graph properties
can be generated using various generation models
\item graph identification-Identify the desired information graph (with the proper and complete
set of nodes and edges for analysis) from a given data graph (which maybe noisy, incomplete,
and at the wrong level of abstraction)
\item graph alignment-Looks at ways objects within a graph correspond to objects in a second graph.
One common name for graph alignment is ontology alignment.
\end{itemize}

As of this time, algorithms have been implemented for generative models,
object classification, link prediction, and entity resolution.

\section{General Philosophy}
\label{philosophy}
Given the motivation presented in \secref{motivation}, GAIA was developed with the following
guidelines:

\begin{itemize}
\item The library should be modular to allow for different parts of GAIA to be developed and
changed independently.  This will allow users to develop just the parts they are interested
in analyzing and still be able to use the other parts of the code.
\item The graph is the connecting piece among the different modules.  For this end,
the graph interface must be general enough to handle graphs of all types and sizes.
Specifically, the graph interface allows for all the nodes, edges, and the graph to
have features.  Moreover, the graph interface supports many different types of features,
including strings, numerics, categorical, and list values.  The features can also
have probabilities associated with each of them.  Next, the graph interface also allows
for both directed and undirected hyperedges.  Finally, the graph interface is independent
of the underlying implementation.  This means different implementations of the graph
interface can be used to efficiently handle the problem at hand.
\item The code should be well documented, both in javadoc and inline comments,
to make using and debugging code easy.  Also, the code should be sufficiently readable
that the code can be used as a guide to understanding the algorithms implemented therein.
\item The code is designed to maximize code reuse.  Commonly used functionality and code should
be inherited or stored as utilities.
\item The code should simplify comparison of different algorithms.  Evaluation statistics
should be implemented so those don't have to be rewritten.
\item Though the code is a library, the code should be set up so that it can be used by a user
with little to no coding or configuration.  This involves setting up Experiment classes
to handle many common tasks over networks, as well as making sure the algorithms
implemented have as many parameters over values to have a default value set.
\item The code should be designed to allow repeatability of experiments.   All implementations
should be set up such that the exact same experiment can be rerun given the used data and
configuration file.
\end{itemize}

\section{Caveats}
Although we are striving to make implementations within GAIA as general
as possible, some implementations may have limitations with regard
to how memory and runtime.  This maybe due to limitations of the
algorithm being implemented itself, as well as practical limitations faced
when attempting to include as many implementations of algorithms
within GAIA as possible.  If running into difficulty with runtime
or running out of memory, make sure to take a look at the Java documentation
written for the implementation in question.
